<?php
header('Content-type:text/html;charset=utf8');
$a = "&lt;style&gt;p{font-size:15px}&lt;/style&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; font-size: large; color: rgb(194, 79, 74);&quot;&gt;5.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;二进制日志&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;5.4.4.1二进制记录格式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;
5.4.4.2设置二进制日志格式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;5.4.4.3混合二进制记录格式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;5.4.4.4更改MySQL数据库表的日志记录格式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;二进制日志包含描述数据库更改(例如表创建操作或表数据更改)的“ 事件 ”。它还包含针对可能进行了更改的语句的事件(例如， DELETE不匹配任何行)，除非使用基于行的日志记录。二进制日志还包含有关每个语句花费该更新数据多长时间的信息。二进制日志有两个重要目的：&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;1.对于复制，主复制服务器上的二进制日志提供了要发送到从属服务器的数据更改的记录。主服务器将其二进制日志中包含的事件发送到其从属服务器，从属服务器执行这些事件以对主服务器进行相同的数据更改。请参见 第16.2节“复制实现”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;2.某些数据恢复操作需要使用二进制日志。还原备份后，将重新执行在执行备份后记录的二进制日志中的事件。这些事件使数据库从备份开始就保持最新状态。请参见 第7.5节“使用二进制日志进行时间点(增量)恢复”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;二进制日志不用于诸如SELECT或 SHOW不修改数据的语句 。要记录所有语句(例如，确定问题查询)，请使用常规查询日志。请参见第5.4.3节“常规查询日志”。&lt;/p&gt;&lt;p&gt;运行启用了二进制日志记录的服务器会使性能稍微降低。但是，二进制日志在使您能够设置复制和进行还原操作方面的好处通常超过了这种较小的性能下降。&lt;/p&gt;&lt;p&gt;二进制日志通常可以抵御意外的暂停，因为仅记录或读回完整的事务。有关更多信息，请参见 第16.3.2节“处理复制从设备的意外中止”。&lt;/p&gt;&lt;p&gt;服务器将重写写在二进制日志中的语句中的密码，以使它们不会以纯文本的形式出现。另请参见 第6.1.2.3节“密码和日志记录”。&lt;/p&gt;&lt;p&gt;以下讨论描述了一些影响二进制日志记录操作的服务器选项和变量。有关完整列表，请参见 第16.1.6.4节“二进制日志记录选项和变量”。&lt;/p&gt;&lt;p&gt;要启用二进制日志，请使用--log-bin[=base_name]选项启动服务器。如果没有给定base_name值，则默认名称是--pid-file选项的值(默认情况下是主机名)，后面跟着-bin。如果给定了基本名，则服务器将文件写入数据目录中，除非给定的基本名包含一个前导绝对路径名，以指定不同的目录。建议您显式地指定一个基名，而不是使用默认的主机名;原因请参阅B.4.7节，“MySQL中的已知问题”。&lt;/p&gt;&lt;p&gt;如果在日志名称中提供扩展名(例如，--log-bin=base_name.extension)，扩展名将被静默删除并忽略。&lt;/p&gt;&lt;p&gt;mysqld将数字扩展追加到二进制日志基名以生成二进制日志文件名。每次服务器创建一个新的日志文件时，这个数字都会增加，从而创建一个有序的文件序列。服务器每次启动或刷新日志时，都会在这个系列中创建一个新文件。当当前日志的大小达到max_binlog_size时，服务器还会自动创建一个新的二进制日志文件。如果您正在使用大型事务，那么二进制日志文件可能会比max_binlog_size更大，因为事务是完整地写入文件的，永远不要在文件之间分割。&lt;/p&gt;&lt;p&gt;为了跟踪使用了哪些二进制日志文件， mysqld还创建了一个二进制日志索引文件，其中包含二进制日志文件的名称。默认情况下，该名称与二进制日志文件具有相同的基本名称，扩展名为 '.index'。您可以使用--log-bin-index[=file_name]选项更改二进制日志索引文件的名称 。当mysqld运行时，您不应该手动编辑该文件 。这样做会使mysqld混淆 。&amp;nbsp;&lt;/p&gt;&lt;p&gt;术语“ 二进制日志文件 ”通常表示包含数据库事件的单独编号文件。术语 “ 二进制日志 ”共同表示一组编号的二进制日志文件加上索引文件。&lt;/p&gt;&lt;p&gt;具有足以设置受限制的会话系统变量的特权的客户机(请参见 第5.1.8.1节“系统变量特权”)可以通过使用SET sql_log_bin=OFF语句禁用其自身语句的二进制记录 。&lt;/p&gt;&lt;p&gt;默认情况下，服务器记录事件的长度以及事件本身，并使用它来验证事件是否正确写入。您还可以通过设置binlog_checksum系统变量使服务器为事件编写校验和 。从二进制日志回读时，默认情况下，主服务器使用事件长度，但可以通过启用master_verify_checksum系统变量使它使用校验和 。从属I / O线程还验证从主控接收到的事件。通过启用slave_sql_verify_checksum系统变量，可以在从中继日志中读取时使从属SQL线程使用校验和(如果可用) 。&lt;/p&gt;&lt;p&gt;二进制日志中记录的事件的格式取决于二进制日志格式。支持三种格式类型：基于行的日志，基于语句的日志和基于混合的日志。使用的二进制日志记录格式取决于MySQL版本。有关日志记录格式的一般说明，请参见 第5.4.4.1节“二进制日志记录格式”。有关二进制日志格式的详细信息，请参见 MySQL内部知识：二进制日志。&lt;/p&gt;&lt;p&gt;服务器使用--binlog-do-db和 --binlog-ignore-db选项相同的方式评估 --replicate-do-db和 --replicate-ignore-db选项。有关如何完成此操作的信息，请参见 第16.2.5.1节“数据库级复制和二进制日志记录选项的评估”。&lt;/p&gt;&lt;p&gt;默认情况下，复制从服务器不会将从复制主服务器收到的任何数据写入其自己的二进制日志中。要记录这些修改，请使用--log-slave-updates选项之外的--log-bin选项启动从属服务器(请参见第16.1.6.3节“复制从站选项和变量”)。当从属服务器还充当链式复制中其他从属服务器的主服务器时，便完成了此操作。&lt;/p&gt;&lt;p&gt;您可以使用RESET MASTER语句删除所有二进制日志文件，或者使用PURGE BINARY LOGS删除其中的一个子集。请参见 第13.7.6.6节“ RESET语句”和第13.4.1.1节“ PURGE BINARY LOGS语句”。&lt;/p&gt;&lt;p&gt;如果使用复制，则在确保没有从属仍需要使用它们之前，不应删除主服务器上的旧二进制日志文件。例如，如果您的从属服务器从未运行超过三天，则可以每天一次在主服务器上执行mysqladmin flush-logs，然后删除超过三天的任何日志。您可以手动删除文件，但是最好使用PURGE BINARY LOGS，它还会为您安全地更新二进制日志索引文件(并且可以使用date参数)。请参见 第13.4.1.1节“ PURGE BINARY LOGS语句”。&lt;/p&gt;&lt;p&gt;您可以使用mysqlbinlog实用程序显示二进制日志文件的内容 。当您要重新处理日志中的语句以进行恢复操作时，此功能很有用。例如，您可以从二进制日志更新MySQL服务器，如下所示：&lt;/p&gt;&lt;blockquote&gt;shell&amp;gt; mysqlbinlog log_file | mysql -h server_name&lt;/blockquote&gt;&lt;p&gt;mysqlbinlog也可用于显示复制从中继日志文件的内容，因为它们使用与二进制日志文件相同的格式编写。有关 mysqlbinlog实用程序及其使用方式的更多信息，请参见 第4.6.7节“ mysqlbinlog-用于处理二进制日志文件的实用程序”。
有关二进制日志和恢复操作的更多信息，请参见 第7.5节“使用二进制日志进行时间点(增量)恢复”。&lt;/p&gt;&lt;p&gt;在语句或事务完成之后但在释放任何锁或完成任何提交之前，立即执行二进制日志记录。这样可以确保日志以提交顺序记录。&lt;/p&gt;&lt;p&gt;非事务表的更新在执行后立即存储在二进制日志中。&lt;/p&gt;&lt;p&gt;在未提交的事务中，所有更改事务性表(如InnoDB表)的更新(UPDATE, DELETE或 INSERT)都被缓存，直到服务器接收到COMMIT语句。此时，mysqld在执行COMMIT之前将整个事务写入二进制日志。&lt;/p&gt;&lt;p&gt;对非事务表的修改不能回滚。如果回滚的事务包括对非事务表的修改，则记录整个事务并在末尾添加一条&lt;spanmicrosoft yahei',=&quot;&quot; '\\5fae软雅黑',=&quot;&quot; '\\5b8b体',=&quot;&quot; 'malgun=&quot;&quot; gothic',=&quot;&quot; meiryo,=&quot;&quot; sans-serif;=&quot;&quot; font-size:=&quot;&quot; 14px;=&quot;&quot; font-style:=&quot;&quot; normal;=&quot;&quot; font-variant:=&quot;&quot; font-weight:=&quot;&quot; letter-spacing:=&quot;&quot; line-height:=&quot;&quot; 26px;=&quot;&quot; orphans:=&quot;&quot; auto;=&quot;&quot; text-align:=&quot;&quot; start;=&quot;&quot; text-indent:=&quot;&quot; 0px;=&quot;&quot; text-transform:=&quot;&quot; none;=&quot;&quot; white-space:=&quot;&quot; widows:=&quot;&quot; word-spacing:=&quot;&quot; -webkit-text-stroke-width:=&quot;&quot; background-color:=&quot;&quot; rgb(247,=&quot;&quot; 248,=&quot;&quot; 250);=&quot;&quot; display:=&quot;&quot; inline=&quot;&quot; !important;=&quot;&quot; float:=&quot;&quot; none;&quot;=&quot;&quot;&gt;ROLLBACK&lt;/spanmicrosoft&gt;语句，以确保复制对这些表的修改。&lt;/p&gt;&lt;p&gt;当处理事务的线程启动时，它为buffer语句分配一个binlog_cache_size的缓冲区。如果语句大于这个值，线程将打开一个临时文件来存储事务。线程结束时删除临时文件。&lt;/p&gt;&lt;p&gt;Binlog_cache_use状态变量显示了使用这个缓冲区(可能还有一个临时文件)来存储语句的事务数量。Binlog_cache_disk_use状态变量显示了这些事务中有多少实际上必须使用临时文件。这两个变量可用于将binlog_cache_size调优为足够大的值，从而避免使用临时文件。&lt;/p&gt;&lt;p&gt;max_binlog_cache_size系统变量(默认为4GB，也是最大值)可用于限制用于缓存多语句事务的总大小。如果事务大于这么多字节，则会失败并回滚。最小值是4096。&lt;/p&gt;&lt;p&gt;如果使用二进制日志和基于行的日志记录，则并发插入将转换为CREATE ... SELECT或 INSERT ... SELECT语句的普通插入。这样做是为了确保您可以通过在备份操作期间应用日志来重新创建表的精确副本。如果您使用基于语句的日志记录，则原始语句将被写入日志。&lt;/p&gt;&lt;p&gt;二进制日志格式具有一些已知的局限性，可能会影响从备份的恢复。请参见第16.4.1节“复制功能和问题”。&lt;/p&gt;&lt;p&gt;如第23.7节“存储的程序二进制日志记录”中所述完成 存储程序的二进制日志记录。&lt;/p&gt;&lt;p&gt;请注意，由于复制功能的增强，MySQL 5.7中的二进制日志格式与以前的MySQL版本不同。请参见第16.4.2节“ MySQL版本之间的复制兼容性”。&lt;/p&gt;&lt;p&gt;如果服务器无法写入二进制日志，刷新二进制日志文件或将二进制日志同步到磁盘，则复制主数据库上的二进制日志可能会变得不一致，并且复制从数据库可能会与主数据库失去同步。binlog_error_action系统变量控制在二进制日志中遇到这种类型的错误时所采取的操作。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;默认设置，ABORT_SERVER使服务器停止二进制日志记录并关闭。此时，您可以确定并纠正错误原因。重新启动后，恢复将继续进行，就像服务器意外中止一样(请参见第16.3.2节“处理复制从属的异常中止 ”)。&lt;/li&gt;&lt;li&gt;设置IGNORE_ERROR提供了与旧版本MySQL的向后兼容性。使用此设置，服务器将继续进行中的事务并记录错误，然后停止二进制日志记录，但继续执行更新。此时，您可以确定并纠正错误原因。要恢复二进制日志记录， log_bin必须再次启用，这需要重新启动服务器。仅在需要向后兼容性且二进制日志在此MySQL服务器实例上为非必需时才使用此选项。例如，您可能只将二进制日志用于服务器的间歇审核或调试，而不将其用于从服务器复制或将其用于时间点还原操作。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;默认情况下，二进制日志在每次写入时都被同步到磁盘(sync_binlog=1)。如果没有启用sync_binlog，并且操作系统或机器(不仅仅是MySQL服务器)崩溃，那么二进制日志的最后一条语句就有可能丢失。要防止这种情况，请启用sync_binlog系统变量在每N个提交组之后将二进制日志同步到磁盘。参见5.1.7节，“服务器系统变量”。sync_binlog最安全的值是1(默认值)，但这也是最慢的。&lt;/p&gt;&lt;p&gt;例如，如果您使用InnoDB表，并且MySQL服务器处理一条COMMIT 语句，它将按顺序将许多准备好的事务写入二进制日志，同步二进制日志，然后将该事务提交到中InnoDB。如果服务器在这两个操作之间崩溃，则事务将InnoDB在重新启动时回滚 ，但仍存在于二进制日志中。假设--innodb_support_xa设置为默认值1，则可以解决此问题 。尽管此选项与XA交易中对InnoDB，还可以确保二进制日志和InnoDB数据文件同步。为了使此选项提供更高的安全性，还应将MySQL服务器配置为InnoDB在提交事务之前将二进制日志和日志同步到磁盘。InnoDB日志默认同步的，并且sync_binlog=1可用于二进制日志同步。此选项的作用是，崩溃后重新启动时，在执行事务回滚之后，MySQL服务器将扫描最新的二进制日志文件以收集事务xid值并计算二进制日志文件中的最后一个有效位置。然后，MySQL服务器会告诉InnoDB完成将已成功写入二进制日志的所有准备好的事务，并将二进制日志截断到最后一个有效位置。这样可以确保二进制日志反映InnoDB表的确切数据 ，因此从服务器与主服务器保持同步，因为它没有收到已回滚的语句。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; color: rgb(194, 79, 74);&quot;&gt;注意&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; color: rgb(194, 79, 74);&quot;&gt;innodb_support_xa已被弃用，将在以后的版本中删除。从MySQL 5.7.10开始，InnoDB始终支持XA事务中的两阶段提交。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果MySQL服务器在崩溃恢复时发现二进制日志比应该的短，那么它至少缺少一个成功提交的InnoDB事务。如果sync_binlog=1，并且磁盘/文件系统在被请求时执行了实际的同步(有些没有)，则不会发生这种情况，因此服务器将打印一条错误消息，即The binary log file_name is shorter than its expected size。在这种情况下，这个二进制日志是不正确的，应该从主数据的新快照重新启动复制。&lt;/p&gt;&lt;p&gt;解析二进制日志时，以下系统变量的会话值将写入二进制日志并由复制从属服务器遵循：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;sql_mode(除非NO_DIR_IN_CREATE模式没有被复制;请参见 第16.4.1.37节“复制和变量”)&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;foreign_key_checks&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;unique_checks&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;character_set_client&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;collation_connection&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;collation_database&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;collation_server&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-size: medium;&quot;&gt;sql_auto_is_null&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; font-size: large; color: rgb(194, 79, 74);&quot;&gt;5.4.4.1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;二进制记录格式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;服务器使用几种日志记录格式将信息记录在二进制日志中。所使用的确切格式取决于所使用的MySQL版本。有三种日志记录格式：&lt;/p&gt;&lt;p&gt;MySQL中的复制功能最初是基于从主服务器到从服务器的SQL语句传播。这称为statement-based logging：基于语句的日志记录。通过使用--binlog-format=STATEMENT启动服务器，可以使用这种格式。&lt;/p&gt;&lt;p&gt;在 row-based logging,：基于行的日志记录中，主进程将事件写入二进制日志，以指示各个表行是如何受到影响的。因此，表总是使用主键来确保能够有效地标识行，这一点非常重要。通过使用——binlog-format=ROW启动服务器，可以使它使用基于行的日志记录。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还有第三个选项:mixed logging(混合日志记录)。对于混合日志记录，默认情况下使用基于语句的日志记录，但是在某些情况下，日志记录模式会自动切换到基于行，如下所述。通过使用选项--binlog-format= mixed启动mysqld，可以使MySQL显式地使用混合日志记录。&lt;/p&gt;&lt;p&gt;日志记录格式还可以通过使用的存储引擎来设置或限制。这有助于消除在使用不同存储引擎的主服务器和从服务器之间复制某些语句时出现的问题。&lt;/p&gt;&lt;p&gt;使用基于语句的复制时，复制不确定性语句可能会出现问题。在确定给定语句对于基于语句的复制是否安全时，MySQL确定是否可以保证可以使用基于语句的日志记录来复制该语句。如果MySQL无法做出此保证，它将标记该语句为潜在不可靠的对象并发出警告，Statement may not be safe to log in statement format.&lt;/p&gt;&lt;p&gt;您可以通过使用MySQL的基于行的复制来避免这些问题。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; font-size: large; color: rgb(194, 79, 74);&quot;&gt;5.4.4.2&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;设置二进制日志格式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过使用--binlog-format=type启动MySQL服务器，可以显式地选择二进制日志格式。支持的type值是:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;STATEMENT 使日志记录基于语句。&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;ROW 使日志记录基于行。&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;MIXED 使日志记录使用混合格式。&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;日志格式也可以在运行时进行切换，但是要注意，在许多情况下，您不能这样做，本部分稍后将对此进行讨论。设置binlog_format系统变量的全局值，以指定更改后连接的客户机的格式:&lt;/p&gt;&lt;blockquote&gt;mysql&amp;gt; SET GLOBAL binlog_format = 'STATEMENT';&lt;br&gt;mysql&amp;gt; SET GLOBAL binlog_format = 'ROW';&lt;br&gt;mysql&amp;gt;SET GLOBAL binlog_format = 'MIXED';&lt;/blockquote&gt;&lt;p&gt;单个客户端可以通过设置binlog_format的session值来控制自己语句的日志格式:&lt;/p&gt;&lt;blockquote&gt;mysql&amp;gt; SET SESSION binlog_format = 'STATEMENT';&lt;br&gt;mysql&amp;gt; SET SESSION binlog_format = 'ROW';&lt;br&gt;mysql&amp;gt;SET SESSION binlog_format = 'MIXED';&lt;/blockquote&gt;&lt;p&gt;更改全局binlog_format值需要足够的权限来设置全局系统变量。更改会话binlog_format值需要足够的权限来设置受限制的会话系统变量。参见5.1.8.1节，“系统变量特权”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;客户端可能希望在每个会话的基础上设置二进制日志记录的原因有以下几点:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对数据库进行许多小更改的会话可能要使用基于行的日志记录。&lt;/li&gt;&lt;li&gt;执行与WHERE子句中的许多行匹配的更新的会话 可能要使用基于语句的日志记录，因为记录几条语句比记录多行会更有效。&lt;/li&gt;&lt;li&gt;有些语句在主服务器上需要大量执行时间，但导致仅修改了几行。因此，使用基于行的日志记录来复制它们可能是有益的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当您无法在运行时切换复制格式时，会有一些例外情况：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;从存储的函数或触发器中。&lt;/li&gt;&lt;li&gt;如果NDB启用了存储引擎。&lt;/li&gt;&lt;li&gt;会话当前处于基于行的复制模式并且具有打开的临时表。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在任何这些情况下尝试切换格式都会导致错误。&lt;/p&gt;&lt;p&gt;当存在任何临时表时，不建议在运行时切换复制格式，因为仅在使用基于语句的复制时才记录临时表，而使用基于行的复制时则不记录临时表。对于混合复制，通常会记录临时表;用户定义函数(udf)和UUID()函数会发生异常。&lt;/p&gt;&lt;p&gt;在复制进行过程中切换复制格式也会导致问题。每个MySQL Server可以设置自己的并且只能设置自己的二进制日志记录格式(无论binlog_format是全局范围还是会话范围，都为true )。这意味着更改复制主服务器上的日志记录格式不会导致从属服务器更改其日志记录格式以匹配。使用 STATEMENT模式时， binlog_format不会复制系统变量。在使用MIXED或 ROW记录模式时，它会被复制，但被从属设备忽略。&lt;/p&gt;&lt;p&gt;复制从站无法将以ROW日志记录格式 接收的二进制日志条目STATEMENT转换为在其自己的二进制日志中使用的格式。因此，如果主服务器需要，则从服务器必须使用ROW或 MIXED格式化。将主服务器上的二进制日志记录格式从更改 STATEMENT为ROW或 MIXED正在进行复制到从属服务器时，其STATEMENT格式会导致复制失败，并显示以下错误，例如 Error executing row event: 'Cannot execute statement: impossible to write to binary log since statement is in row format and BINLOG_FORMAT = STATEMENT.' 将从站上的二进制日志记录格式更改为STATEMENT当主服务器仍在使用时格式化MIXED或 ROW格式化也会导致相同类型的复制失败。为了安全地更改格式，必须停止复制并确保在主服务器和从服务器上都进行了相同的更改。&lt;/p&gt;&lt;p&gt;如果使用InnoDB表，并且事务隔离级别为READ COMMITTED或READ UNCOMMITTED，则只能使用基于行的日志记录。可以将日志格式更改为STATEMENT，但是在运行时这样做会很快导致错误，因为InnoDB不能再执行插入。&lt;/p&gt;&lt;p&gt;将二进制日志格式设置ROW为时，使用基于行的格式将许多更改写入二进制日志。但是，某些更改仍然使用基于语句的格式。实例包括所有DDL(数据定义语言)语句，例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。&lt;/p&gt;&lt;p&gt;--binlog-row-event-max-size 选项可用于能够进行基于行的复制的服务器。行以块大小存储在二进制日志中，块大小不超过此选项的值。该值必须是256的倍数。默认值为8192。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; color: rgb(249, 150, 59);&quot;&gt;警告&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; color: rgb(249, 150, 59);&quot;&gt;当使用基于语句的日志记录进行复制时，如果以一种不确定的方式修改数据的方式设计语句，则主服务器和从服务器上的数据可能会有所不同 。也就是说，它由查询优化器决定。通常，即使在复制之外，这也不是一个好习惯。有关此问题的详细说明，请参见 第B.4.7节“ MySQL中的已知问题”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;有关复制从服务器保存的日志的信息，请参见 第16.2.4节“复制中继和状态日志”。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; font-size: large; color: rgb(194, 79, 74);&quot;&gt;5.4.4.3&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;混合二进制记录格式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当以MIXED日志记录格式运行时，服务器在以下情况下自动从基于语句的记录切换为基于行的记录：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;当一个函数包含UUID()时。&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;当更新一个或多个具有AUTO_INCREMENT列的表并调用触发器或存储函数时。与所有其他不安全语句一样，如果binlog_format =STATEMENT，将生成一个警告。&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: small;&quot;&gt;有关更多信息，请参见第16.4.1.1节“复制和AUTO_INCREMENT”。&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;当视图主体需要基于行的复制时，创建视图的语句也会使用它。例如，当创建视图的语句使用UUID()函数时，就会发生这种情况。&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;当涉及到对UDF的调用时。&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;如果一个语句是按行记录的，并且执行该语句的会话有任何临时表，则按行记录将用于所有后续语句(访问临时表的语句除外)，直到该会话使用的所有临时表都被删除为止。&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: small;&quot;&gt;无论是否实际记录了任何临时表，这都是正确的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: small;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 无法使用基于行的格式记录临时表;因此，一旦使用了基于行的日志记录，使用该表的所有后续语句都是不安全的。服务器通过将会话期间执行的所有语句视为不安全的，直到会话不再持有任何临时表，从而近似于这种情况。&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;使用FOUND_ROWS()或ROW_COUNT()时。(Bug #12092, Bug #30244)&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;当使用USER()、CURRENT_USER()或CURRENT_USER时。(错误# 28086)&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;当一个语句引用一个或多个系统变量时。(错误# 31168)&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: small;&quot;&gt;例外。 以下系统变量(仅与会话范围一起使用)不会导致切换日志记录格式：&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;auto_increment_increment&lt;/li&gt;&lt;li&gt;auto_increment_offset&lt;/li&gt;&lt;li&gt;character_set_client&lt;/li&gt;&lt;li&gt;character_set_connection&lt;/li&gt;&lt;li&gt;character_set_database&lt;/li&gt;&lt;li&gt;character_set_server&lt;/li&gt;&lt;li&gt;collation_connection&lt;/li&gt;&lt;li&gt;collation_database&lt;/li&gt;&lt;li&gt;collation_server&lt;/li&gt;&lt;li&gt;foreign_key_checks&lt;/li&gt;&lt;li&gt;identity&lt;/li&gt;&lt;li&gt;last_insert_id&lt;/li&gt;&lt;li&gt;lc_time_names&lt;/li&gt;&lt;li&gt;pseudo_thread_id&lt;/li&gt;&lt;li&gt;sql_auto_is_null&lt;/li&gt;&lt;li&gt;time_zone&lt;/li&gt;&lt;li&gt;timestamp&lt;/li&gt;&lt;li&gt;unique_checks&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: small;&quot;&gt;有关确定系统变量范围的信息，请参见 第5.1.8节“使用系统变量”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: small;&quot;&gt;有关复制如何处理的信息 sql_mode，请参见 第16.4.1.37节“复制和变量”。&lt;/span&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;当涉及的表之一是mysql数据库中的日志表时 。&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;使用该LOAD_FILE()功能时。(错误39701)&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; color: rgb(194, 79, 74);&quot;&gt;注意&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; color: rgb(194, 79, 74);&quot;&gt;如果您试图使用基于语句的日志记录来执行应该使用基于行的日志记录来编写的语句，则会生成一个警告。该警告在客户机中(在SHOW WARNINGS的输出中)和通过mysqld错误日志显示。每次执行这样的语句时，都会向SHOW WARNINGS表添加一个警告。但是，只有为每个客户端会话生成警告的第一个语句被写入错误日志，以防止日志泛滥。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;除了上述决定外，各个引擎还可以确定更新表中信息时使用的日志记录格式。单个引擎的日志记录功能可以定义如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;如果引擎支持基于行的日志记录，则称该引擎具有行记录功能。&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;如果引擎支持基于语句的日志记录，则该引擎被称为具有语句记录能力。&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;给定的存储引擎可以支持一种或两种日志格式。下表列出了每个引擎支持的格式。&lt;/p&gt;&lt;table border=&quot;0&quot; width=&quot;100%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;&amp;nbsp;储存引擎&lt;/th&gt;&lt;th&gt;支持行记录&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;&lt;th&gt;支持语句记录&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;ARCHIVE&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;BLACKHOLE&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;CSV&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;EXAMPLE&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp; No&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;FEDERATED&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;HEAP&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;InnoDB&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;当事务隔离级别为可重复读取或可序列化时，为Yrs;否则No。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;MyISAM&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;MERGE&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;NDB&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp; No&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;是否一个语句是要记录与要使用的是根据语句的类型所确定的记录模式(安全，不安全，或二进制注入)，二进制日志记录格式(STATEMENT，ROW，或 MIXED)，并且存储发动机的记录功能(具有陈述能力，具有行能力，或者两者都没有)。(二进制注入是指记录必须使用ROW格式记录的更改。)&lt;br&gt;&lt;/p&gt;&lt;p&gt;可能会在有或没有警告的情况下记录语句;失败的语句不会记录，但是会在日志中生成错误。如下决策表所示。 Type， binlog_format， SLC和 RLC列概述了条件，而Error / Warning 和Logged as列表示相应的操作。SLC 代表“有语句记录能力 ”，而 RLC代表 “有行记录能力 ”。&lt;/p&gt;&lt;table border=&quot;0&quot; width=&quot;100%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;&amp;nbsp;Type&lt;/th&gt;&lt;th&gt;binlog_format&amp;nbsp;&lt;/th&gt;&lt;th&gt;SLC&amp;nbsp;&lt;/th&gt;&lt;th&gt;RLC&amp;nbsp;&lt;/th&gt;&lt;th&gt;Error/Warning&amp;nbsp;&lt;/th&gt;&lt;th&gt;Logged as&amp;nbsp;&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;*&lt;/td&gt;&lt;td&gt;&amp;nbsp;*&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute statement: 二进制日志记录是不可能的，因为至少涉及到一个既无行能力又无语句能力的引擎。&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Safe&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Safe&lt;/td&gt;&lt;td&gt;&amp;nbsp;MIXED&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Safe&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute statement:二进制日志记录是不可能的，因为BINLOG_FORMAT = 
ROW和至少有一个表使用的存储引擎不能进行基于行的日志记录。&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Unsafe&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Warning: Unsafe statement binlogged in statement format, since BINLOG_FORMAT 
= STATEMENT&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Unsafe&lt;/td&gt;&lt;td&gt;&amp;nbsp;MIXED&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute statement: 
如果存储引擎仅限于基于语句的日志记录，那么不安全语句的二进制日志记录是不可能的，即使BINLOG_FORMAT = MIXED也是如此。.&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Unsafe&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute statement:二进制日志记录是不可能的，因为BINLOG_FORMAT = 
ROW和至少有一个表使用的存储引擎不能进行基于行的日志记录。&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Row Injection&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute row injection: 
二进制日志记录是不可能的，因为至少有一个表使用的存储引擎不能进行基于行的日志记录。&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Row Injection&lt;/td&gt;&lt;td&gt;&amp;nbsp;MIXED&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute row injection: 
二进制日志记录是不可能的，因为至少有一个表使用的存储引擎不能进行基于行的日志记录。&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Row Injection&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute row injection: 
二进制日志记录是不可能的，因为至少有一个表使用的存储引擎不能进行基于行的日志记录。&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Safe&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute statement: 二进制日志记录是不可能的，因为BINLOG_FORMAT =STATEMENT 
和至少有一个表使用的存储引擎不能进行基于语句的日志记录。&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Safe&lt;/td&gt;&lt;td&gt;&amp;nbsp;MIXED&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Safe&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Unsafe&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute statement: 二进制日志记录是不可能的，因为BINLOG_FORMAT =STATEMENT 
和至少有一个表使用的存储引擎不能进行基于语句的日志记录。&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Unsafe&lt;/td&gt;&lt;td&gt;&amp;nbsp;MIXED&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Unsafe&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Row Injection&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute row injection: 二进制日志记录是不可能的，因为BINLOG_FORMAT = 
STATEMENT.&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Row Injection&lt;/td&gt;&lt;td&gt;&amp;nbsp;MIXED&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Row Injection&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;td&gt;&amp;nbsp;No&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Safe&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Safe&lt;/td&gt;&lt;td&gt;&amp;nbsp;MIXED&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Safe&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Unsafe&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Warning: Unsafe statement binlogged in statement format since BINLOG_FORMAT = 
STATEMENT.&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Unsafe&lt;/td&gt;&lt;td&gt;&amp;nbsp;MIXED&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Unsafe&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Row Injection&lt;/td&gt;&lt;td&gt;&amp;nbsp;STATEMENT&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Error: Cannot execute row injection: 二进制日志记录是不可能的，因为BINLOG_FORMAT 
=STATEMENT.&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Row Injection&lt;/td&gt;&lt;td&gt;&amp;nbsp;MIXED&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;nbsp;Row Injection&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;Yes&lt;/td&gt;&lt;td&gt;&amp;nbsp;-&lt;/td&gt;&lt;td&gt;&amp;nbsp;ROW&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当确定产生警告时，将产生标准的MySQL警告(并且可以使用SHOW WARNINGS)。该信息也被写入mysqld错误日志。每个客户端连接的每个错误实例仅记录一个错误，以防止泛滥日志。日志消息包含尝试的SQL语句。&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果log_error_verbosity在从属服务器上大于等于2，则从属服务器会将错误消息打印到错误日志中，以提供有关其状态的信息，例如二进制日志和中继日志坐标(从其开始工作时，切换到另一个中继日志时，它会在断开连接，对于基于语句的日志记录不安全的语句等之后重新连接。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold; font-size: large; color: rgb(194, 79, 74);&quot;&gt;5.4.4.4&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;更改MySQL数据库表的日志记录格式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;mysql数据库中的grant表的内容可以直接修改(例如，使用INSERT或DELETE)，也可以间接修改(例如，使用grant或CREATE USER)。影响mysql数据库表的语句使用以下规则写入二进制日志:&lt;/p&gt;&lt;p&gt;根据binlog_format系统变量的设置，直接记录mysql数据库表中更改数据的数据操作语句。这与INSERT、UPDATE、DELETE、REPLACE、DO、LOAD DATA、SELECT和TRUNCATE表等语句有关。&lt;/p&gt;&lt;p&gt;不管binlog_format的值是多少，间接更改mysql数据库的语句都会被记录为语句。这涉及语句，例如 GRANT， REVOKE， SET PASSWORD， RENAME USER， CREATE(所有形式的除外 CREATE TABLE ... SELECT)， ALTER(所有形式的)，和DROP(各种形式)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;CREATE TABLE ... SELECT是数据定义和数据处理的组合。CREATE TABLE部分使用语句格式记录，SELECT部分根据binlog_format的值记录。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;";
echo strlen($a);
// class HttpRequest{    
//     private static $isShow = false;    
//     // public function __set($attr, $value){        
//     //     $this->$attr = $value;    
//     // }    
//     public static function send($url,$data=null){        
//         $curl = curl_init();            
//         // 设置请求的url地址        
//         curl_setopt($curl, CURLOPT_URL, $url);        
//         // 直接跳过安全证书的验证        
//         curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false);        
//         curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);        
//         // 根据$data判断是post还是get方式                    
//         if (!empty($data)) {            
//             // 如果$data非空，则为post方式            
//             curl_setopt($curl, CURLOPT_POST, true);            
//             curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
//       }        
//         // 反之为get方式        
//         if (!self::$isShow) {            
//             // 不直接显示数据，而是以返回值的形式            
//             curl_setopt($curl, CURLOPT_RETURNTRANSFER, 0);        
//         }        
//         $res = curl_exec($curl);        
//         return $res;        
//         curl_close($curl);    
//     }
// }
// // 调用封装的类，请求知乎php话题下的数据
// $res = HttpRequest::send('http://www.acourse.net/course?c=3&t=3&f=2&ps=-1&pb=-1&o=time-desc');
// // 根据样式设置正则匹配模式，筛选所需数据
// $reg = '/<a[^>]*><span[^>]*>(.+?)<\/span><\/a>/';
// preg_match_all($reg, $res, $match);
// var_dump($match);


// function tttt($var){
//     return $var;
// }

// $a1=array("a","b",2,3,4);
// print_r(array_filter($a1,"tttt"));
echo strrev(md5('haoruiadmin123456'));

?>